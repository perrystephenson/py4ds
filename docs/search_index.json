[
["index.html", "Python for Data Science 1 Introduction 1.1 What is Python? 1.2 Setting up Python 1.3 Getting Help", " Python for Data Science Perry Stephenson 2018-09-30 1 Introduction This book has a target audience of one person: myself. I’m writing it as a reference for myself as I learn Python and start to transition from being 100% R to more of a 50/50 language mix. I’m making it public for two reasons: It’s easier for me to access my notes from anywhere without a password It might be useful for someone else who’s trying to figure out how to do something in Python It’s eventually going to resemble an opinionated manual, where I thoroughly document the bits of the language that I think are worth using, and completely ignore the bits I don’t use. This may or may not be useful for other people! It’s also going to make a lot of comparisons between R and Python, for my benefit. 1.1 What is Python? Python is a language. IPython is an interactive shell (which is itself tautologous, as all shells are interactive, surely?). Python is the name of the language, and there are multiple implementations of Python, including CPython (the reference implementation), PyPy (a faster implemenetation), and more. This is different to R, which is both a language AND an implementation, meaning that the R language is defined by the behaviour of the R interpreter. R runs in both script mode and interactive mode, which is again a key difference. So Python is to R as IPython is to R as CPython is to R. Easy! 1.2 Setting up Python This is a Python book written in R Markdown. This means that all of the Python examples are being excuted via the reticulate package. The Python distribution for all of these examples is Anaconda Python (version 3.6), and the packages are being managed within a conda environment. I decided to use Conda to manage my Python environment based on the discussion in this blog post and to make sure that I had full control over the environment. To set up a new Macbook (MacOS Mojave) with Python, I: Visited https://www.anaconda.com/download/#macos in a web browser and downloaded the Python 3.6 installer, then installed it. Created a new conda environment for this project (conda create --name py4ds python=3.6) Installed numpy, pandas and matplotlib into the conda environment using conda activate py4ds then conda install numpy pandas matplotlib Configured reticulate to use the new environment (and load a package to force it to load this non-default environment) # R library(reticulate) use_condaenv(condaenv = &#39;py4ds&#39;, require = TRUE, conda = &#39;/Users/perrystephenson/anaconda3/bin/conda&#39;) import(&#39;pandas&#39;) ## Module(pandas) Now we can check that the correct version of Python is being used: # Python import sys print(sys.version) ## 3.6.6 |Anaconda, Inc.| (default, Jun 28 2018, 11:10:00) ## [GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] And to make sure everything is working properly, I’ll generate a plot with matplotlib. # Python import matplotlib.pyplot as plt plt.plot([0, 2, 1, 4]) plt.show() 1.3 Getting Help Getting help about a Python function is pretty easy, using the help(&lt;thing&gt;) syntax (for example help(len)). The documentation seems a bit sparse, so I suspect that Google is also a pretty good place to go when looking for help on a function or a feature. "],
["syntax.html", "2 Base Syntax 2.1 Types 2.2 Comments 2.3 Basic Operations 2.4 Strings 2.5 Lists / Arrays / Columns / Vectors 2.6 Indexing 2.7 Copy / Modify 2.8 Grouping 2.9 Missing values and extreme numbers 2.10 Booleans 2.11 Dictionaries 2.12 Functions 2.13 Methods 2.14 Namespaces", " 2 Base Syntax This chapter will cover the basics of Base Python, that is the syntax of the Python Interpreter without any non-bundled packages. Note Python does not automatically print the result of expressions. They must always be wrapped in a print() function call if you want them to be printed to the standard output. 2.1 Types Python is “dynamically typed” which means that it can automatically infer the types of variables, and these types can change throughout the course of your script. This is similar to R, but very different to C. To see the type of an object in Python, use type(var). x = 0.5 print(type(x)) ## &lt;class &#39;float&#39;&gt; 2.2 Comments Comments start with the hash #, just like in R and Bash. You can also use docstrings as the first statement inside a function - this is written like a multi-line comment which becomes the documentation for the function. # This is a comment &quot;&quot;&quot;This is a multi-line docstring &quot;&quot;&quot; 2.3 Basic Operations The standard operators are pretty straightforward (*, /, +, -), exponentiation is ** (i.e. 4**2) instead of ^. Assignment is = and function arguments are also passed via =. Equality tests use ==. print(2**2 == 4) ## True print(2 == 3) ## False 2.4 Strings Python accepts both single ' and double &quot; quotes. You can concatenate strings using the + operator - cool! Python does not automatically cast between strings and other types (booooooo) which means you have to cast it explicitly when you want to build error messages, turn strings into numeric types, etc. x = 0.75 msg = &#39;The value of x is &#39; + str(x) print(msg) ## The value of x is 0.75 2.5 Lists / Arrays / Columns / Vectors In R, if you define something using the inline notation c(1.73, 1.68, 1.71, 1.89) then you are creating an “atomic vector” (i.e. a vector containing only one type of data). In Python, if you define something using the inline notation [1.73, 1.68, 1.71, 1.89] then are creating a “list”. “List” seems to have the same meaning as R (can contain multiple types, can contain other lists, etc), so it is just the notation that differs. There is no base equivalent to the atomic vector in Python - it seems that this functionality is provided by the NumPy Array. 2.6 Indexing Python uses 0-based indexing, whereas R uses 1-based indexing. If you want to select the 4th element in a vector, you would use index 4 in R (1,2,3,4), but index 3 in Python (0,1,2,3). The syntax for this in Python is the same as R - var[3]. Negative indices work very differently! In R, a negative index will return the vector with the specified item removed i.e. if you use var[-3] then you will get the vector without the third element. In Python however, it will select a single element by counting backwards. An index of -1 returns the final element (because you start at index zero and take one step backwards), -2 returns the second last element, and so on. Slicing works even more strangely in Python. Whilst in R, using index var[3:5] will return the 3rd, 4th and 5th elements, in Python this will only return the 4th and 5th elements. This is because the syntax in Python is [inclusive:exclusive] and because of 0-based indexing. One nice shortcut in Python (not present in R) is the [:n] and [n:] syntax. In the first case, the blank argument to the infix operator : is interpreted as a 0, and in the second case the blank argument is interpreted as the length of the vector (so that it will select the rest of the vector). Python lists can be joined using the + operator. example = [0,1,2] + [3,4] print(example) ## [0, 1, 2, 3, 4] Deleting elements is a bit different - you need to use del(var[3]) to remove an element from the list. del(example[3]) print(example) ## [0, 1, 2, 4] 2.7 Copy / Modify R has a nice “copy on modify” behaviour, which means that when you assign a list (or anything else) to a new variable, it doesn’t copy it until you make a change, at which point it saves a modified copy of that object. In Python however, the behaviour is different for different data types (booooooo). Lists, for example, are copied by reference, which means that changing an element in a “copied” list also changes the same element in the original list. To get around this you need to do something like y = list(x) or y = x[:] to explicitly copy all items from the list. x = [1,2,3,4] y = x y[2] = 5 print(x) ## [1, 2, 5, 4] x = [1,2,3,4] y = list(x); y[2] = 5 z = x[:]; z[2] = 5 print(x) ## [1, 2, 3, 4] 2.8 Grouping Python does not use braces - it uses indentation to group blocks of code. This is supposed to improve readability, but in practice it can be super messy. Can use spaces or tabs. if condition : execute this and this because we&#39;re still indented execute this regardless because we&#39;ve got no indent 2.9 Missing values and extreme numbers In R, you have NA (missing) and NULL (undefined, empty), NaN (not a number), and Inf (infinity). In Python, you have None, and numpy has numpy.nan (not a number). There is no equivalent to Inf, as it just raises an error. 2.10 Booleans In R, booleans are defined as TRUE and FALSE, with the shortcut T and F also commonly used. In Python, the booleans are simply defined as True and False. Boolean arithmetic is performed using the and and or keywords, corresponding to the &amp; and | operators in R. You can also use the not operator, which corresponds to ! in R. Booleans are a bit harder to work with when you’re using numpy arrays, because the base logic keywords are not vectorised. To work with numpy arrays, you have to use the built in numpy functions: np.logical_and() np.locical_or() np.locical_not() 2.11 Dictionaries Dictionaries don’t really exist in R, because the dictionary functionality (named elements) is available in both atomic vectors and lists. To create a dictionary in Python, you can use the following syntax: world = {&quot;afghanistan&quot;:30.55, &quot;albania&quot;:2.77, &quot;algeria&quot;:39.21} You can also do nested dictionaries - the keys are somewhat limited (they can be any immutable data type) but the values can be dictionaries if you want. 2.12 Functions Functions are defined using the keyword def, like so: def repeat(s, exclaim): &quot;&quot;&quot; Returns the string &#39;s&#39; repeated 3 times. If exclaim is true, add exclamation marks. &quot;&quot;&quot; result = s + s + s if exclaim: result = result + &#39;!!!&#39; return result print(repeat(&#39;ha&#39;, exclaim = True)) ## hahaha!!! A return statement appears to be compulsory in Python functions, unlike in R where it is not strictly required. Like in all other scripting languages, functions must be defined before they are used (i.e. earlier in the script). Importing modules is probably a sensible way to manage this. Function arguments look to be specified and evaluated similarly to R - you name the arguments and you can give them default values in the definition statement. When using the function you can resolve arguments by name or by order (but you cannot mix the two approaches), and there is no partial matching. 2.13 Methods Python is a proper object-oriented (OO) language, unlike R which is a functional language with three different OO systems built on top of it. The Python model for objects and methods is most similar to R’s Reference Classes (RC) framework. In Python, methods belong to objects (you invoke them using object.method() notation), and behave according to the type of the object. Some methods can mutate the object they belong to, others do not, and there is no easy way to tell the difference without reading the documentation. 2.14 Namespaces If you have a module called binky.py and a function in that module called foo() then the fully qualified function name is binky.foo(). This is sort of like R’s :: notation (e.g. dplyr::select()) except that Python modules seem to typically be more light weight than R packages. "],
["control-flow.html", "3 Control Flow 3.1 If statements 3.2 While loop 3.3 For loop", " 3 Control Flow Bottom line up front, Python is weird about groupings. Instead of using braces and making things clear and explicit, Python enforces indentation as a way of grouping code. What this means if you have both spaces and tabs is unclear, but it’s certainly going to get confusing. Add to this Python’s mixed bag when it comes to putting function arguments in brackets and we’ve got a real mess. 3.1 If statements The general syntax for an if statement is: if condition : execute this and this because we&#39;re still indented execute this regardless because we&#39;ve got no indent The general syntax for an if else statement is: if condition : execute this else : execute this The general syntax for an else if statement is: if condition : execute this elif condition : execute this else : execute this 3.2 While loop The general syntax for a while loop is: while condition : expression 3.3 For loop The general syntax for a for loop is: for var in seq : expression You can also do inline enumeration if you want to (to get access to the index as well as the value), but it’s a bit flimsy and hard to understand because it only exists in the for loop syntax (so you can’t easily debug how it works): for index, var in enumerate(seq): expression You can also iterate along multiple columns in nested lists: for room, area in house : expression To iterate through the rows of a pandas DataFrame, you can use the following: for lab, row in df.iterrows() : print(lab) # The row label print(row) # The pandas Series, i.e. a named list consisting of the row elements "],
["scripting.html", "4 Scripting 4.1 Imports 4.2 Boilerplate", " 4 Scripting 4.1 Imports If you import a module using import sys, then you make the functions from sys available in your code using their fully qualified function names, e.g. sys.argv and sys.exit(). This is different to R, where using the library() function makes functions available using their short names, e.g. after calling library(dplyr) you can just call select(). To get this sort of behaviour in Python, some people use from sys import argv, exit which makes specified functions available using their short names. In general though, it makes sense to use fully qualified names unless they’re really long, in the same way that it makes sense to use functions in R using the :: notation. To save you a bit of typing, you can rename the imported packages using the import &lt;package&gt; as &lt;shortcut&gt; syntax, e.g. import numpy as np. Going further, you can even do things like from numpy import array as np_array to import specific functions and rename them all in one step. Python has a “standard library” of imports available, just like R. Some examples include sys, re and os. You can also import constants from packages - e.g. math.pi. Some important imports include: numpy, matplotlib, pandas. 4.2 Boilerplate #!/usr/bin/env python import sys def main(): print(&#39;Hello there&#39;, sys.argv[1]) if __name__ == &#39;__main__&#39;: main() In this example: the shebang will use the correct Python conda environment (based on whichever conda env is active when the script is executed) the package imports are included at the top of the file the main() function is the part of the code that should run when you execute the script from the command line The strange thing at the end calls the main() function "],
["numpy-numeric-python.html", "5 Numpy (Numeric Python) 5.1 Numpy arrays 5.2 Two dimensional numpy arrays", " 5 Numpy (Numeric Python) This is a package which provides some types and functions for maths. The key use of numpy is the numpy.array() function, which provides something similar to the c() function (atomic vector) in R. Unlike lists (in both R and Python), the numpy.array() function allows vectorised operations. By convention, numpy is normally imported as np. 5.1 Numpy arrays To create a numpy array: import numpy as np temp = np.array([1,2,3,4]) print(temp) ## [1 2 3 4] Note the strange bracket nesting - it looks like the array function takes a list as an argument, which means you need to use the square brackets to make a list, then pass this list as the argument to the array function. One dimensional numpy arrays are useful for R users, because they behave like atomic vectors in R; in fact numpy arrays are also atomic - they can only hold items with the same data type. 5.2 Two dimensional numpy arrays You can define n-dimensional numpy arrays using lists of lists. The highest level of the hierarchy is the first dimension of the n-dimensional array, the second level is the second dimension of the array, and so on. When working with a two dimensional array, this means that you can create a 2 row, 5 column numpy array using the following command: import numpy as np np_2d = np.array([[1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]) print(np_2d) ## [[ 1 2 3 4 5] ## [ 6 7 8 9 10]] To interrogate the properties of the array you can use methods. For example, you can get the dimensions of the array using np_2d.shape - this would be written as dim(np_2d) in R. print(np_2d.shape) ## (2, 5) "],
["pandas.html", "6 Pandas 6.1 Creation 6.2 Subsetting", " 6 Pandas The pandas package was written by Wes McKinney (who seems to be Hadley Wickham’s counterpart for Python) and builds on top of the numpy package to provide DataFrames. 6.1 Creation To create a DataFrame manually: import pandas as pd dict = { &quot;country&quot;: [&#39;Brazil&#39;, &#39;Russia&#39;, &#39;India&#39;, &#39;China&#39;, &#39;South Africa&#39;], &quot;capital&quot;: [&#39;Brasilia&#39;, &#39;Moscow&#39;, &#39;New Delhi&#39;, &#39;Beijing&#39;, &#39;Pretoria&#39; ], &quot;area&quot;: [ 8.516, 17.10, 3.286, 9.597, 1.221 ], &quot;population&quot;: [ 200.4, 143.5, 1252, 1357, 52.98 ]} df = pd.DataFrame(dict) df.index = [&#39;BR&#39;, &#39;RU&#39;, &#39;IN&#39;, &#39;CH&#39;, &#39;SA&#39; ] print(df) ## country capital area population ## BR Brazil Brasilia 8.516 200.40 ## RU Russia Moscow 17.100 143.50 ## IN India New Delhi 3.286 1252.00 ## CH China Beijing 9.597 1357.00 ## SA South Africa Pretoria 1.221 52.98 Alternatively, if you have data in a CSV file you can import it using: df = pd.read_csv(&#39;&lt;path&gt;&#39;) # If there are no column names df = pd.read_csv(&#39;&lt;path&gt;&#39;, index_col = 0) # If there are column names 6.2 Subsetting To select a column in pandas, use df['country']. This returns a “pandas Series” object, which is like a 1D element of a data frame. If you want to get a data frame back instead of a series, use df[['country']]. This is the opposite of R, where the [[]] is used to drill down further than []. The reason for this is that [] defines a list in Python, so you’re really calling df[&lt;subset&gt;] where &lt;subset&gt; is a list of length 1. In R, the [[]] subset operator is actually a function, hence the differing behaviours. This means that subsetting for multiple columns in Python doesn’t take too much writing: df[['country', 'capital']]. Interestingly, and perhaps confusingly, if you provide a slice (range) to df[] then you will be subsetting on rows, not columns! Using df[1:4] selects the 2nd through 4th rows of the data frame. If you want to do anything more complex than this, it starts getting a bit weird, and you have to use the loc() method (which stands for “location”). To pull out a named row, you need to use the df.loc['RU'] syntax (which returns a Series object), or df.loc[['RU']] (which returns a DataFrame). You can also select multiple rows this way: df.loc[['RU', 'IN', 'CH']]. You can then extend this to subset on columns as well, which starts to look a bit more like R (and like the 2D numpy array): df.loc[['RU', 'IN', 'CH'], ['country', 'capital']]. If you want to use an index, then you can do the same thing with lists of integers passed to the iloc() method (which stands for index-location). It seems like you probably need to chain these functions together if you want to have a mix of subsetting approaches. "]
]
